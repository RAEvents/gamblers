{"version":3,"file":"app.js.map","mappings":"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","names":["apiBaseUrl","buildRequestUrl","baseUrl","endpointUrl","authObject","args","withArgs","replaceAll","queryParamValues","z","username","y","webApiKey","argKey","argValue","Object","entries","includes","replace","String","URLSearchParams","toString","call","async","url","config","headers","Headers","rawResponse","fetch","undefined","window","ok","Error","status","statusText","json","s","serializeProperties","originalData","options","shouldCastToNumbers","shouldMapToBooleans","returnValue","Array","isArray","cleanedArray","entity","push","cleanedObject","originalKey","originalValue","sanitizedValue","Number","_extends","naiveCamelCase","toUpperCase","toLowerCase","camelCased","charAt","slice","ClaimSetType","ClaimStatus","ClaimType","AchievementDistributionFlags","GameExtendedClaimType","getUserProfile","authorization","payload","u","buildAuthorization","sleep","ms","resolve","sleepBase","apiFailures","wait","resetBackoff","checkUser","auth","profile","$","e","html","literals","expr","string","index","literal","getAuthorization","obj","E","showAuthModal","modal","button","ev","users","untracked","switchToTab","progress","amount","i","user","result","div","elem","target","name"],"ignoreList":[],"sources":["../node_modules/.pnpm/@retroachievements+api@https+++codeload.github.com+monkey-bug+retroachievements-api-js+tar.gz_vyvfriklwvtsuiyi2sn2u7rusu/node_modules/@retroachievements/api/src/utils/internal/apiBaseUrl.ts","../node_modules/.pnpm/@retroachievements+api@https+++codeload.github.com+monkey-bug+retroachievements-api-js+tar.gz_vyvfriklwvtsuiyi2sn2u7rusu/node_modules/@retroachievements/api/src/utils/internal/buildRequestUrl.ts","../node_modules/.pnpm/@retroachievements+api@https+++codeload.github.com+monkey-bug+retroachievements-api-js+tar.gz_vyvfriklwvtsuiyi2sn2u7rusu/node_modules/@retroachievements/api/src/utils/internal/call.ts","../node_modules/.pnpm/@retroachievements+api@https+++codeload.github.com+monkey-bug+retroachievements-api-js+tar.gz_vyvfriklwvtsuiyi2sn2u7rusu/node_modules/@retroachievements/api/src/utils/internal/serializeProperties.ts","../node_modules/.pnpm/@retroachievements+api@https+++codeload.github.com+monkey-bug+retroachievements-api-js+tar.gz_vyvfriklwvtsuiyi2sn2u7rusu/node_modules/@retroachievements/api/src/feed/models/claim-set-type.enum.ts","../node_modules/.pnpm/@retroachievements+api@https+++codeload.github.com+monkey-bug+retroachievements-api-js+tar.gz_vyvfriklwvtsuiyi2sn2u7rusu/node_modules/@retroachievements/api/src/feed/models/claim-status.enum.ts","../node_modules/.pnpm/@retroachievements+api@https+++codeload.github.com+monkey-bug+retroachievements-api-js+tar.gz_vyvfriklwvtsuiyi2sn2u7rusu/node_modules/@retroachievements/api/src/feed/models/claim-type.enum.ts","../node_modules/.pnpm/@retroachievements+api@https+++codeload.github.com+monkey-bug+retroachievements-api-js+tar.gz_vyvfriklwvtsuiyi2sn2u7rusu/node_modules/@retroachievements/api/src/game/models/achievement-distribution-flags.enum.ts","../node_modules/.pnpm/@retroachievements+api@https+++codeload.github.com+monkey-bug+retroachievements-api-js+tar.gz_vyvfriklwvtsuiyi2sn2u7rusu/node_modules/@retroachievements/api/src/game/models/get-game-extended-response.model.ts","../node_modules/.pnpm/@retroachievements+api@https+++codeload.github.com+monkey-bug+retroachievements-api-js+tar.gz_vyvfriklwvtsuiyi2sn2u7rusu/node_modules/@retroachievements/api/src/ticket/getTicketData.ts","../node_modules/.pnpm/@retroachievements+api@https+++codeload.github.com+monkey-bug+retroachievements-api-js+tar.gz_vyvfriklwvtsuiyi2sn2u7rusu/node_modules/@retroachievements/api/src/user/getUserProfile.ts","../node_modules/.pnpm/@retroachievements+api@https+++codeload.github.com+monkey-bug+retroachievements-api-js+tar.gz_vyvfriklwvtsuiyi2sn2u7rusu/node_modules/@retroachievements/api/src/utils/public/buildAuthorization.ts","../src/api.js","../src/app.js"],"sourcesContent":["export const apiBaseUrl = \"https://retroachievements.org/API\";\n","import type { AuthObject } from \"../public/models\";\n\nexport const buildRequestUrl = (\n  baseUrl: string,\n  endpointUrl: string,\n  authObject: AuthObject,\n  args: Record<string, string | number> = {}\n) => {\n  const concatenated = `${baseUrl}/${endpointUrl}`;\n  const withoutDoubleSlashes = concatenated.replaceAll(/([^:]\\/)\\/+/g, \"$1\");\n\n  let withArgs = withoutDoubleSlashes;\n\n  // `z` and `y` are expected query params from the RA API.\n  // Authentication is handled purely by query params.\n  const queryParamValues: Record<string, string> = {\n    z: authObject.username,\n    y: authObject.webApiKey,\n  };\n\n  for (const [argKey, argValue] of Object.entries(args)) {\n    // \"abc.com/some-route/:foo/some-path\" & {\"foo\": 4} --> \"abc.com/some-route/4/some-path\"\n    if (withArgs.includes(`:${argKey}`)) {\n      withArgs = withArgs.replace(`:${argKey}`, String(argValue));\n    } else if (argValue !== undefined) {\n      queryParamValues[argKey] = String(argValue);\n    }\n  }\n\n  const queryString = new URLSearchParams(queryParamValues).toString();\n  return `${withArgs}?${queryString}`;\n};\n","declare const PACKAGE_VERSION: string | undefined;\n\n/**\n * Fetch an HTTP resource. This is publicly exposed in the\n * event you would like to access an endpoint that this\n * library does not currently support.\n *\n * UNLESS YOU'RE SURE OF WHAT YOU'RE DOING, YOU PROBABLY\n * SHOULDN'T USE THIS FUNCTION.\n */\nexport const call = async <\n  T extends readonly any[] | Record<string, any>\n>(config: {\n  url: string;\n}) => {\n  const { url } = config;\n\n  const headers = new Headers({\n    \"User-Agent\": `RetroAchievements-api-js/${PACKAGE_VERSION ?? \"Unknown\"}`,\n  });\n\n  const rawResponse = await fetch(url, (typeof window !== undefined) ? {} : { headers });\n\n  if (!rawResponse.ok) {\n    throw new Error(\n      `HTTP Error: Status ${rawResponse.status} ${rawResponse.statusText}`\n    );\n  }\n\n  return (await rawResponse.json()) as T;\n};\n","/* eslint-disable sonarjs/cognitive-complexity */\n/* eslint-disable sonarjs/prefer-immediate-return */\n\nexport const serializeProperties = (\n  originalData: any,\n  options: Partial<{\n    shouldCastToNumbers: string[];\n    shouldMapToBooleans: string[];\n  }> = {}\n) => {\n  const { shouldCastToNumbers, shouldMapToBooleans } = options;\n\n  let returnValue = originalData;\n\n  if (Array.isArray(originalData)) {\n    const cleanedArray: any[] = [];\n\n    for (const entity of originalData) {\n      cleanedArray.push(serializeProperties(entity, options));\n    }\n\n    returnValue = cleanedArray;\n  } else if (!Array.isArray(originalData) && originalData instanceof Object) {\n    let cleanedObject: Record<string, any> = {};\n\n    for (const [originalKey, originalValue] of Object.entries(originalData)) {\n      let sanitizedValue = originalValue;\n      if (shouldCastToNumbers?.includes(originalKey)) {\n        sanitizedValue = originalValue === null ? null : Number(originalValue);\n      }\n\n      if (shouldMapToBooleans?.includes(originalKey)) {\n        if (originalValue === null) {\n          sanitizedValue = null;\n        } else {\n          sanitizedValue = String(originalValue) === \"1\" ? true : false;\n        }\n      }\n\n      cleanedObject = {\n        ...cleanedObject,\n        [naiveCamelCase(originalKey)]: serializeProperties(\n          sanitizedValue,\n          options\n        ),\n      };\n    }\n\n    returnValue = cleanedObject;\n  }\n\n  return returnValue;\n};\n\nconst naiveCamelCase = (originalValue: string) => {\n  // \"ID\" --> \"id\", \"URL\" --> \"url\"\n  if (originalValue.toUpperCase() === originalValue) {\n    return originalValue.toLowerCase();\n  }\n\n  // \"GameID\" -> \"gameID\"\n  let camelCased =\n    originalValue.charAt(0).toLowerCase() + originalValue.slice(1);\n\n  // \"gameID\" -> \"gameId\"\n  camelCased = camelCased.replaceAll(\"ID\", \"Id\");\n\n  // \"badgeURL\" --> \"badgeUrl\"\n  camelCased = camelCased.replaceAll(\"URL\", \"Url\");\n\n  // \"rAPoints\" -> \"raPoints\"\n  camelCased = camelCased.replaceAll(\"rA\", \"ra\");\n\n  // \"visibleUserawards\" -> \"visibleUserAwards\"\n  camelCased = camelCased.replaceAll(\"visibleUserawards\", \"visibleUserAwards\");\n\n  return camelCased;\n};\n","export enum ClaimSetType {\n  NewSet = 0,\n  Revision = 1,\n}\n","export enum ClaimStatus {\n  Active = 0,\n  Complete = 1,\n  Dropped = 2,\n}\n","export enum ClaimType {\n  Primary = 0,\n  Collaboration = 1,\n}\n","export enum AchievementDistributionFlags {\n  CoreAchievements = 3,\n  UnofficialAchievements = 5,\n}\n","// NOTE: This cannot be a true extension of the `GetGameResponse`\n// interface because the return types for many of these fields\n// are different from the actual RA API.\n\nenum GameExtendedClaimType {\n  Primary = \"0\",\n  Collaboration = \"1\",\n}\n\nexport interface GameExtendedRawAchievementEntity {\n  ID: string;\n  NumAwarded: string;\n  NumAwardedHardcore: string;\n  Title: string;\n  Description: string;\n  Points: string;\n  TrueRatio: string;\n  Author: string;\n  DateModified: string;\n  DateCreated: string;\n  BadgeName: string;\n  DisplayOrder: string;\n  MemAddr: string;\n}\n\ninterface GameExtendedRawClaimEntity {\n  User: string;\n  SetType: string;\n  ClaimType: GameExtendedClaimType;\n  Created: string;\n  Expiration: string;\n}\n\nexport interface GetGameExtendedResponse {\n  ID: number;\n  Title: string;\n  ConsoleID: number;\n  ForumTopicID: number;\n  Flags: number;\n  ImageIcon: string;\n  ImageTitle: string;\n  ImageIngame: string;\n  ImageBoxArt: string;\n  Publisher: string;\n  Developer: string;\n  Genre: string;\n  Released: string;\n  IsFinal: boolean;\n  ConsoleName: string;\n  RichPresencePatch: string;\n  NumAchievements: number;\n  NumDistinctPlayersCasual: string;\n  NumDistinctPlayersHardcore: string;\n  Claims: GameExtendedRawClaimEntity[];\n  Achievements: Record<number, GameExtendedRawAchievementEntity> | [];\n}\n","import type { ID } from \"../utils/internal\";\nimport {\n  apiBaseUrl,\n  buildRequestUrl,\n  call,\n  serializeProperties,\n} from \"../utils/internal\";\nimport type { AuthObject } from \"../utils/public\";\nimport type {\n  AchievementTicketStats,\n  GameTicketStats,\n  MostTicketedGames,\n  RecentTickets,\n  TicketEntity,\n  UserTicketStats,\n} from \"./models\";\n\ninterface GetTicketDataAllPayloadValues {\n  ticketId?: string | number;\n  offset?: number;\n  count?: number;\n  isGettingMostTicketedGames?: true;\n  username?: string;\n  gameId?: string | number;\n  isGettingTicketsForUnofficialAchievements?: true;\n  shouldReturnTicketsList?: true;\n  achievementId?: string | number;\n}\n\n/**\n * BEGIN: Function overload definitions\n */\n\n/**\n * A call to this function will retrieve ticket metadata information\n * about a single achievement ticket, targeted by its ticket ID.\n *\n * @param authorization An object containing your username and webApiKey.\n * This can be constructed with `buildAuthorization()`.\n *\n * @param payload.ticketId The ID of the ticket to get information about.\n *\n * @example\n * ```\n * const ticketData = await getTicketData(\n *   authorization,\n *   { ticketId: 12345 }\n * );\n * ```\n *\n * @returns An object containing metadata about a target ticket.\n */\nexport function getTicketData(\n  authorization: AuthObject,\n  payload: { ticketId: ID }\n): Promise<TicketEntity>;\n\n/**\n * A call to this function will retrieve ticket metadata information\n * about the latest opened achievement tickets on RetroAchievements.\n *\n * @param authorization An object containing your username and webApiKey.\n * This can be constructed with `buildAuthorization()`.\n *\n * @param payload.count Optional. Defaults to 10. Max is 100.\n * How many tickets to retrieve.\n *\n * @param payload.offset Optional. Defaults to 0.\n * Number of tickets to skip. This can be used for pagination.\n *\n * @example\n * ```\n * const ticketData = await getTicketData(authorization);\n * ```\n *\n * @returns A list of the most recently opened tickets on the site.\n */\nexport function getTicketData(\n  authorization: AuthObject,\n  payload?: Partial<{ offset: number; count: number }>\n): Promise<RecentTickets>;\n\n/**\n * A call to this function will retrieve the games on the site with\n * the highest count of opened achievement tickets.\n *\n * @param authorization An object containing your username and webApiKey.\n * This can be constructed with `buildAuthorization()`.\n *\n * @param payload.count Optional. Defaults to 10. Max is 100.\n * How many ticketed games to retrieve.\n *\n * @param payload.offset Optional. Defaults to 0.\n * Number of games to skip. This can be used for pagination.\n *\n * @example\n * ```\n * const ticketData = await getTicketData(\n *   authorization,\n *   { isGettingMostTicketedGames: true }\n * );\n * ```\n *\n * @returns A list of the most recently opened tickets on the site.\n */\nexport function getTicketData(\n  authorization: AuthObject,\n  payload: { isGettingMostTicketedGames: true; offset?: number; count?: number }\n): Promise<MostTicketedGames>;\n\n/**\n * A call to this function will retrieve an achievement developer's\n * ticket stats, targeted by that developer's username.\n *\n * @param authorization An object containing your username and webApiKey.\n * This can be constructed with `buildAuthorization()`.\n *\n * @param payload.username The developer's account username to retrieve\n * ticket stats for.\n *\n * @example\n * ```\n * const ticketData = await getTicketData(\n *   authorization,\n *   { username: \"xelnia\" }\n * );\n * ```\n *\n * @returns An achievement developer's ticket stats.\n */\nexport function getTicketData(\n  authorization: AuthObject,\n  payload: { username: string }\n): Promise<UserTicketStats>;\n\n/**\n * A call to this function will retrieve a game's ticket stats, targeted\n * by the game's ID. If you are unsure of a game's ID, visit its page\n * on the RetroAchievements website and copy the number at the end of the URL.\n *\n * @param authorization An object containing your username and webApiKey.\n * This can be constructed with `buildAuthorization()`.\n *\n * @param payload.gameId The game ID to fetch ticket stats for.\n *\n * @param payload.isGettingTicketsForUnofficialAchievements Optional. Fetch stats\n * for unofficial/non-core achievements that have tickets.\n *\n * @param payload.shouldReturnTicketsList Optional. If true, not only fetches a\n * game's ticket stats, but also returns a list of tickets for the game.\n *\n * @example\n * ```\n * const ticketData = await getTicketData(\n *   authorization,\n *   { gameId: 14_402 }\n * );\n * ```\n *\n * @returns A game's ticket stats, potentially also including the ticket list.\n */\nexport function getTicketData(\n  authorization: AuthObject,\n  payload: {\n    gameId: ID;\n    isGettingTicketsForUnofficialAchievements?: true;\n    shouldReturnTicketsList?: true;\n  }\n): Promise<GameTicketStats>;\n\n/**\n * A call to this function will retrieve the an achievement's\n * ticket stats, targeted by the achievement's ID. If you are unsure\n * of an achievement's ID, open its page on the RetroAchievements\n * website and copy the number at the end of the URL.\n *\n * @param authorization An object containing your username and webApiKey.\n * This can be constructed with `buildAuthorization()`.\n *\n * @param payload.achievementId The ID of the achievement to fetch ticket\n * stats for.\n *\n * @example\n * ```\n * const ticketData = await getTicketData(\n *   authorization,\n *   { achievementId: 12345 }\n * );\n * ```\n *\n * @returns An achievement developer's ticket stats.\n */\nexport function getTicketData(\n  authorization: AuthObject,\n  payload: { achievementId: ID }\n): Promise<AchievementTicketStats>;\n\n/**\n * END: Function overload definitions\n */\n\nexport async function getTicketData(\n  authorization: AuthObject,\n  payload: GetTicketDataAllPayloadValues = {}\n) {\n  const queryParams = buildGetTicketDataQueryParams(payload);\n\n  const url = buildRequestUrl(\n    apiBaseUrl,\n    \"/API_GetTicketData.php\",\n    authorization,\n    queryParams\n  );\n\n  const rawResponse = await call({ url });\n\n  return serializeProperties(rawResponse, {\n    shouldCastToNumbers: [\n      \"ID\",\n      \"AchievementID\",\n      \"Points\",\n      \"GameID\",\n      \"ReportType\",\n      \"ReportState\",\n      \"OpenTickets\",\n    ],\n    shouldMapToBooleans: [\"Hardcore\"],\n  });\n}\n\nconst buildGetTicketDataQueryParams = (\n  payload: GetTicketDataAllPayloadValues\n) => {\n  const {\n    ticketId,\n    isGettingMostTicketedGames,\n    username,\n    gameId,\n    isGettingTicketsForUnofficialAchievements,\n    shouldReturnTicketsList,\n    achievementId,\n  } = payload;\n\n  let queryParams: Record<string, string | number> = {};\n\n  if (ticketId !== undefined) {\n    queryParams[\"i\"] = ticketId;\n  } else if (isGettingMostTicketedGames) {\n    queryParams[\"f\"] = \"1\";\n    queryParams = applyPaginationQueryParams(queryParams, payload);\n  } else if (username) {\n    queryParams[\"u\"] = username;\n  } else if (gameId) {\n    queryParams[\"g\"] = gameId;\n\n    if (isGettingTicketsForUnofficialAchievements) {\n      queryParams[\"f\"] = \"5\";\n    }\n\n    if (shouldReturnTicketsList) {\n      queryParams[\"d\"] = \"1\";\n    }\n  } else if (achievementId) {\n    queryParams[\"a\"] = achievementId;\n  } else {\n    queryParams = applyPaginationQueryParams(queryParams, payload);\n  }\n\n  return queryParams;\n};\n\nconst applyPaginationQueryParams = (\n  currentParams: Record<string, string | number>,\n  payload: Partial<{ count: number; offset: number }>\n) => {\n  const modifiedParams = { ...currentParams };\n\n  if (payload.count !== undefined) {\n    modifiedParams[\"c\"] = payload.count;\n  }\n\n  if (payload.offset !== undefined) {\n    modifiedParams[\"o\"] = payload.offset;\n  }\n\n  return modifiedParams;\n};\n","import {\n  apiBaseUrl,\n  buildRequestUrl,\n  call,\n  serializeProperties,\n} from \"../utils/internal\";\nimport type { AuthObject } from \"../utils/public\";\nimport type { GetUserProfileResponse, UserProfile } from \"./models\";\n\n/**\n * A call to this function will retrieve summary information about\n * a given user, targeted by username.\n *\n * @param authorization An object containing your username and webApiKey.\n * This can be constructed with `buildAuthorization()`.\n *\n * @param payload.username The user for which to retrieve the summary for.\n *\n * @example\n * ```\n * const userSummary = await getUserProfile(\n *   authorization,\n *   { username: \"xelnia\" }\n * );\n * ```\n *\n * @returns An object containing profile summary metadata about a target user.\n */\nexport const getUserProfile = async (\n  authorization: AuthObject,\n  payload: {\n    username: string;\n  }\n): Promise<UserProfile> => {\n  const { username } = payload;\n\n  const url = buildRequestUrl(\n    apiBaseUrl,\n    \"/API_GetUserProfile.php\",\n    authorization,\n    { u: username }\n  );\n\n  const rawResponse = await call<GetUserProfileResponse>({ url });\n\n  return serializeProperties(rawResponse, {\n    shouldCastToNumbers: [\n      \"TotalPoints\",\n      \"TotalSoftcorePoints\",\n      \"TotalTruePoints\",\n      \"Permissions\",\n    ],\n    shouldMapToBooleans: [\"Untracked\", \"UserWallActive\"],\n  });\n};\n","import type { AuthObject } from \"./models\";\n\n/**\n * Accepts your RetroAchievements.org username and web API key. After\n * receiving these inputs, the function returns you a value that can be\n * used for the authentication parameter by any of the async calls in this\n * library.\n *\n * Your account's personal Web API Key can be found on the Settings page\n * of RetroAchievements.org. Do not use a Web API Key that is not associated\n * with your account.\n *\n * @returns An `AuthObject` that you can pass to any of the API call functions.\n *\n * @example\n * ```\n * const authorization = buildAuthorization({\n *   username: \"Scott\",\n *   webApiKey: \"LtjCwW16nJI7cqOyPIQtXk8v1cfF0tmO\"\n * });\n * ```\n */\nexport const buildAuthorization = (options: AuthObject): AuthObject => {\n  if (!options.username || !options.webApiKey) {\n    throw new Error(`\n      buildAuthorization() requires an object containing a\n      username and webApiKey. eg:\n\n      const authorization = buildAuthorization({\n        username: \"myUserName\",\n        webApiKey: \"myWebApiKey\"\n      })\n    `);\n  }\n\n  return options;\n};\n\n// This function simply returns what it's given, however the return\n// value has the added benefit of type safety.\n","import { getUserProfile, getGameInfoAndUserProgress, getAchievementUnlocks } from \"@retroachievements/api\";\nimport { getOption } from \"./options.js\";\n\nconst sleep = ms => new Promise(resolve => setTimeout(() => resolve(), ms));\n\nconst sleepBase = 200;\nconst maxTries = 5;\nlet apiFailures = 0;\n\nexport async function wait() {\n    await sleep(sleepBase * Math.pow(2, apiFailures));\n}\n\nexport function resetBackoff() {\n    apiFailures = 0;\n}\n\nfunction formatDate(date) {\n    const year = date.getUTCFullYear();\n    const month = String(date.getUTCMonth() + 1).padStart(2, \"0\");\n    const day = String(date.getUTCDate()).padStart(2, \"0\");\n\n    switch (getOption(\"dateFormat\")) {\n        case 0:\n            return `${year}-${month}-${day}`;\n        case 1:\n            return `${month}/${day}/${year}`;\n        case 2:\n            return `${day}/${month}/${year}`;\n        case 3:\n            return `${month}-${day}-${year}`;\n        case 4:\n            return `${day}-${month}-${year}`;\n    }\n}\n\nexport async function checkGame(auth, username, id, startDate, endDate) {\n    let result;\n    for (let i = 0;; i++) {\n        try {\n            result = await getGameInfoAndUserProgress(auth, {\n                username,\n                gameId: id,\n                shouldIncludeHighestAwardMetadata: true,\n            });\n        } catch (e) {\n            apiFailures += 1;\n            await wait();\n            if (i < maxTries) continue;\n        }\n\n        break;\n    }\n\n    let status = \"failure\";\n    switch (result.highestAwardKind) {\n        case \"mastered\":\n            status = \"success mastered\";\n            break;\n        case \"beaten-hardcore\":\n            status = \"success\";\n            break;\n        default:\n            break;\n    }\n\n    const awardDate = new Date(result.highestAwardDate);\n    if (awardDate < startDate || awardDate > endDate) {\n        status = \"failure\";\n    }\n\n    const timestamp = result.highestAwardDate ? formatDate(awardDate) : \"N/A\";\n\n    const alt = document.getElementById(\"altUsername\").value;\n    if (username != alt && alt.length && status == \"failure\") {\n        const altResult = await checkGame(auth, alt, id, startDate);\n        if (altResult.status.includes(\"success\")) {\n            altResult.status += \" alt\";\n            return altResult;\n        }\n    }\n\n    return {\n        status,\n        title: result.title,\n        icon: result.imageIcon,\n        timestamp,\n    }\n}\n\nexport async function checkAchievement(auth, username, id, startDate, endDate) {\n    let info, game;\n    for (let i = 0;; i++) {\n        try {\n            info = await getAchievementUnlocks(auth, { count: 1, achievementId: id });\n            game = await getGameInfoAndUserProgress(auth, {\n                username,\n                gameId: info.game.id,\n                shouldIncludeHighestAwardMetadata: false,\n            });\n        } catch (e) {\n            apiFailures += 1;\n            await wait();\n            if (i < maxTries) continue;\n        }\n\n        break;\n    }\n\n    const achievement = game.achievements[info.achievement.id];\n    const unlocked = achievement.dateEarnedHardcore != \"\";\n    const unlockedDate = unlocked ? new Date(achievement.dateEarnedHardcore) : new Date(0);\n\n    const result = {\n        status: unlocked && (unlockedDate >= startDate && unlockedDate <= endDate) ? \"success\" : \"failure\",\n        timestamp: unlocked ? formatDate(unlockedDate) : \"N/A\",\n        title: info.achievement.title,\n        icon: `/Badge/${achievement.badgeName}.png`,\n    }\n\n    if (result.status == \"failure\") {\n        const alt = document.getElementById(\"altUsername\").value;\n        if (alt.length && alt != username) {\n            const altResult = await checkAchievement(auth, alt, id, startDate, endDate);\n            if (altResult.status == \"success\") {\n                altResult.status += \" alt\";\n                return altResult;\n            }\n        }\n    }\n\n    return result;\n}\n\nexport async function checkUser(auth, username) {\n    try {\n        const profile = await getUserProfile(auth, { username });\n        return { untracked: profile.untracked, username, userPic: profile.userPic };\n    } catch (e) {\n        if (e.message.includes(\"404\")) {\n            return { untracked: true, username, userPic: `/UserPic/${username}.png` };\n        }\n    }\n}\n","import { buildAuthorization } from \"@retroachievements/api\";\nimport { compress, decompress } from \"./compression.js\";\nimport { getOption, setOption } from \"./options.js\";\nimport * as api from \"./api.js\";\nimport \"./css/style.css\";\n\nfunction html(literals, ...expr) {\n    let string = \"\";\n\n    for (const [index, literal] of literals.entries()) {\n        string += literal;\n        if (index in expr) string += expr[index];\n    }\n\n    return string;\n}\n\nasync function getAuthorization() {\n    if (!localStorage.getItem(\"auth\")) {\n        return await showAuthModal();\n    } else {\n        const obj = JSON.parse(localStorage.getItem(\"auth\"));\n        if (\"apikey\" in obj) {\n            obj.webApiKey = obj.apikey;\n            delete obj.apikey;\n            localStorage.setItem(\"auth\", JSON.stringify(obj));\n        }\n        const auth = buildAuthorization(obj);\n        auth.toString = function() {\n            return `z=${this.username}&y=${this.webApiKey}`;\n        }\n        return auth;\n    }\n}\n\nfunction showAuthModal() {\n    let template = document.getElementById(\"authModalTemplate\");\n    let modal = template.content.cloneNode(true);\n    let button = modal.children[0].querySelector(\"button\");\n    document.body.appendChild(modal);\n\n    return new Promise(resolve => {\n        button.addEventListener(\"click\", ev => {\n            let modal = document.querySelector(\"div.authModal\");\n            let auth = {\n                username: modal.querySelector(\"input[name='username']\").value,\n                webApiKey: modal.querySelector(\"input[name='apikey']\").value,\n            };\n            if (modal.querySelector(\"input[name='saveinfo']\").checked) {\n                localStorage.setItem(\"auth\", JSON.stringify(auth));\n            }\n            document.body.removeChild(modal);\n            resolve(buildAuthorization(auth));\n        });\n    });\n}\n\ndocument.getElementById(\"verify\").addEventListener(\"click\", async () => {\n    const auth = await getAuthorization();\n\n    api.resetBackoff();\n\n    const users = Array.from(document.getElementById(\"users\").value.split(\"\\n\"));\n    const untracked = [];\n\n    switchToTab(\"output\");\n    output.innerHTML = html`\n        <h1>Untracked</h1><hr />\n        <div class=\"progress\">\n            <span class=\"spinner\"></span>\n            <span class=\"amount\"></span>\n        </div>\n    `;\n\n    const progress = output.querySelector(\".progress\");\n    const amount = output.querySelector(\".progress > .amount\");\n\n    let i = 0;\n    for (const user of users) {\n        const result = await api.checkUser(auth, user);\n        if (result.untracked) {\n            untracked.push(result);\n        }\n        await api.wait();\n        amount.innerText = `${++i} / ${users.length}`;\n    }\n\n    if (untracked.length == 0) {\n        progress.innerHTML = `No untracked users!`;\n        return;\n    }\n\n    for (const user of untracked) {\n        const div = document.createElement(\"div\");\n        div.className = \"user\";\n        div.innerHTML = html`\n            <img src=${`https://retroachievements.org${user.userPic}`}></img>\n            <a href=${`https://retroachievements.org/user/${user.username}`}>${user.username}</span>\n        `;\n        progress.parentElement.append(div);\n    }\n    progress.remove();\n});\n\ndocument.getElementById(\"clear\").addEventListener(\"click\", () => {\n    document.getElementById(\"users\").value = \"\";\n    document.getElementById(\"output\").innerHTML = \"\";\n    switchToTab(\"submission\");\n});\n\ndocument.getElementById(\"resetAuth\").addEventListener(\"click\", () => {\n    localStorage.removeItem(\"auth\");\n});\n\nfor (const elem of document.querySelectorAll(\"#tabs > div\")) {\n    const target = elem.dataset.target;\n    elem.addEventListener(\"mousedown\", () => {\n        switchToTab(target);\n    });\n}\n\nfunction switchToTab(name) {\n    document.getElementById(name).style.display = \"block\";\n    for (const elem of document.querySelectorAll(`#content > :not(#${name})`)) {\n        elem.style.display = \"none\";\n    }\n    for (const elem of document.querySelectorAll(\"#tabs > div\")) {\n        elem.classList.remove(\"selected\");\n        if (elem.dataset.target == name) {\n            elem.classList.add(\"selected\");\n        }\n    }\n}\n\n"]}